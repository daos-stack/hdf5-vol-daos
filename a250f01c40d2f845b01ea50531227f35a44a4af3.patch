From a250f01c40d2f845b01ea50531227f35a44a4af3 Mon Sep 17 00:00:00 2001
From: Mohamad Chaarawi <mohamad.chaarawi@intel.com>
Date: Tue, 28 Sep 2021 20:59:11 +0000
Subject: [PATCH] API updates, Property support, and auto oclass selection

- add support for pool labels, and switch to use the v1.3 API for
  pool connect and container open.
- add a new environment variable (HDF5_DAOS_FILE_PROP) and file creation
  property to allow user to set DAOS property entries on file creation
  such as the container label, RF factor, etc.
- Change the default oclass for objects to be set by DAOS to be compatible
  with the container RF factor.
- fixes to attribute ordering and link creation ordering (tasks were running away).

Signed-off-by: Mohamad Chaarawi <mohamad.chaarawi@intel.com>
---
 src/daos_vol.c                       | 168 +++++++++++--------
 src/daos_vol.h                       |  19 ++-
 src/daos_vol_attr.c                  |   2 +
 src/daos_vol_file.c                  | 238 ++++++++++++++++++---------
 src/daos_vol_link.c                  |  10 +-
 src/daos_vol_obj.c                   |   6 +-
 src/daos_vol_public.h                |  27 ++-
 src/daos_vol_testing.c               |  10 +-
 test/daos_vol/h5daos_test_oclass.c   |   6 +
 test/daos_vol/h5daos_test_recovery.c |  58 +------
 test/vol                             |   2 +-
 11 files changed, 323 insertions(+), 223 deletions(-)

diff --git a/src/daos_vol.c b/src/daos_vol.c
index f8b556d..f340a3f 100644
--- a/src/daos_vol.c
+++ b/src/daos_vol.c
@@ -49,12 +49,6 @@ do {                                                                  \
         (*next_oidx_ptr) = H5_DAOS_OIDX_FIRST_USER;                   \
 } while(0)
 
-#define H5_DAOS_PRINT_UUID(uuid) do {       \
-    char uuid_buf[37];                      \
-    uuid_unparse(uuid, uuid_buf);           \
-    printf("POOL UUID = %s\n", uuid_buf);   \
-} while (0)
-
 /************************************/
 /* Local Type and Struct Definition */
 /************************************/
@@ -62,13 +56,10 @@ do {                                                                  \
 /* Task user data for pool connect */
 typedef struct H5_daos_pool_connect_ud_t {
     H5_daos_req_t *req;
-    uuid_t *puuid;
+    const char *pool;
     daos_handle_t *poh;
     daos_pool_info_t *info;
-    const char *grp;
-#if !defined(DAOS_API_VERSION_MAJOR) || DAOS_API_VERSION_MAJOR < 1
-    d_rank_list_t *svc;
-#endif
+    const char *sys;
     unsigned int flags;
 } H5_daos_pool_connect_ud_t;
 
@@ -89,6 +80,7 @@ typedef struct H5_daos_obj_open_ud_t {
 /* Local Prototypes */
 /********************/
 
+static herr_t H5_daos_set_prop(hid_t fcpl_id, const char *prop_str);
 static herr_t H5_daos_set_object_class(hid_t plist_id, char *object_class);
 static herr_t H5_daos_str_prop_delete(hid_t prop_id, const char *name,
     size_t size, void *_value);
@@ -350,10 +342,9 @@ const daos_size_t H5_daos_fillval_key_size_g         = (daos_size_t)(sizeof(H5_d
  * Purpose:     Modify the file access property list to use the DAOS VOL
  *              connector defined in this source file.
  *
- *              pool_uuid identifies the UUID of the DAOS pool to connect
- *              to. pool_grp identifies the server group name to use when
- *              connecting to the DAOS pool. This may be NULL, in which
- *              case a default group name is used.
+ *              pool identifies the UUID or label of the DAOS pool to connect to. sys_name
+ *              identifies the DAOS server system to use when connecting to the DAOS pool. This may
+ *              be NULL, in which case a default system is used.
  *
  * Return:      Non-negative on success/Negative on failure
  *
@@ -363,7 +354,7 @@ const daos_size_t H5_daos_fillval_key_size_g         = (daos_size_t)(sizeof(H5_d
  *-------------------------------------------------------------------------
  */
 herr_t
-H5Pset_fapl_daos(hid_t fapl_id, const uuid_t pool_uuid, const char *pool_grp)
+H5Pset_fapl_daos(hid_t fapl_id, const char *pool, const char *sys_name)
 {
     H5_daos_acc_params_t fa;
     H5I_type_t           idType = H5I_UNINIT;
@@ -379,8 +370,8 @@ H5Pset_fapl_daos(hid_t fapl_id, const uuid_t pool_uuid, const char *pool_grp)
         D_GOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "couldn't determine property list class");
     if(!is_fapl)
         D_GOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "not a file access property list");
-    if(uuid_is_null(pool_uuid))
-        D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "not a valid UUID");
+    if(pool == NULL)
+        D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "not a valid POOL");
 
     /* Ensure HDF5 is initialized */
     if(H5open() < 0)
@@ -408,16 +399,13 @@ H5Pset_fapl_daos(hid_t fapl_id, const uuid_t pool_uuid, const char *pool_grp)
     } /* end if */
 
     /* Initialize driver specific properties */
-    uuid_copy(fa.pool_uuid, pool_uuid);
-
-    memset(fa.pool_group, '\0', sizeof(fa.pool_group));
-    if(pool_grp) {
-        size_t pool_grp_name_len = strlen(pool_grp);
+    strncpy(fa.pool, pool, DAOS_PROP_LABEL_MAX_LEN);
+    fa.pool[DAOS_PROP_LABEL_MAX_LEN] = 0;
 
-        if(pool_grp_name_len > H5_DAOS_MAX_GRP_NAME)
-            D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "service group name is too long");
-        else if(pool_grp_name_len > 0)
-            strncpy(fa.pool_group, pool_grp, H5_DAOS_MAX_GRP_NAME - 1);
+    memset(fa.sys, '\0', sizeof(fa.sys));
+    if(sys_name) {
+	strncpy(fa.sys, sys_name, DAOS_SYS_NAME_MAX);
+	fa.sys[DAOS_SYS_NAME_MAX] = 0;
     }
 
     ret_value = H5Pset_vol(fapl_id, H5_DAOS_g, &fa);
@@ -426,6 +414,67 @@ H5Pset_fapl_daos(hid_t fapl_id, const uuid_t pool_uuid, const char *pool_grp)
     D_FUNC_LEAVE_API;
 } /* end H5Pset_fapl_daos() */
 
+herr_t
+H5daos_set_prop(hid_t fcpl_id, const char *prop_str)
+{
+    htri_t      is_fcpl;
+    herr_t      ret_value = SUCCEED;
+
+    H5_daos_inc_api_cnt();
+
+    /* Check arguments */
+    if(fcpl_id == H5P_DEFAULT)
+        D_GOTO_ERROR(H5E_PLIST, H5E_BADVALUE, FAIL, "can't set values in default property list");
+    if((is_fcpl = H5Pisa_class(fcpl_id, H5P_FILE_CREATE)) < 0)
+        D_GOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "couldn't determine property list class");
+    if(!is_fcpl)
+        D_GOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "not a file create property list");
+    if(prop_str == NULL)
+        D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "not a valid DAOS property string");
+
+    if(fcpl_id == H5P_DEFAULT)
+        D_GOTO_ERROR(H5E_PLIST, H5E_BADVALUE, FAIL, "can't set values in default property list");
+
+    /* Call internal routine */
+    if(H5_daos_set_prop(fcpl_id, prop_str) < 0)
+        D_GOTO_ERROR(H5E_VOL, H5E_CANTSET, FAIL, "can't set DAOS properties");
+
+done:
+    D_FUNC_LEAVE_API;
+} /* end H5daos_set_prop() */
+
+static herr_t
+H5_daos_set_prop(hid_t fcpl_id, const char *prop_str)
+{
+    char        *copied_prop;
+    htri_t      prop_exists;
+    herr_t      ret_value = SUCCEED;
+
+    /* Check if the property already exists on the property list */
+    if((prop_exists = H5Pexist(fcpl_id, H5_DAOS_FILE_PROP_NAME)) < 0)
+        D_GOTO_ERROR(H5E_VOL, H5E_CANTGET, FAIL, "can't check for object class property");
+
+    /* Copy object class */
+    if(prop_str)
+        if(NULL == (copied_prop = strdup(prop_str)))
+            D_GOTO_ERROR(H5E_RESOURCE, H5E_CANTALLOC, FAIL, "can't copy prop string");
+
+    /* Set the property, or insert it if it does not exist */
+    if(prop_exists) {
+        if(H5Pset(fcpl_id, H5_DAOS_FILE_PROP_NAME, &copied_prop) < 0)
+            D_GOTO_ERROR(H5E_PLIST, H5E_CANTSET, FAIL, "can't set property");
+    } /* end if */
+    else
+        if(H5Pinsert2(fcpl_id, H5_DAOS_FILE_PROP_NAME, sizeof(char *),
+                &copied_prop, NULL, NULL,
+                H5_daos_str_prop_delete, H5_daos_str_prop_copy,
+                H5_daos_str_prop_compare, H5_daos_str_prop_close) < 0)
+            D_GOTO_ERROR(H5E_PLIST, H5E_CANTINSERT, FAIL, "can't insert property into list");
+
+done:
+    D_FUNC_LEAVE;
+} /* end H5_daos_set_prop() */
+
 
 /*-------------------------------------------------------------------------
  * Function:    H5daos_set_object_class
@@ -535,8 +584,11 @@ H5_daos_set_oclass_from_oid(hid_t plist_id, daos_obj_id_t oid)
     herr_t ret_value = SUCCEED;
 
     /* Get object class id from oid */
-    /* Replace with DAOS function once public! DSINC */
+#if CHECK_DAOS_API_VERSION(1, 6)
+    oc_id = daos_obj_id2class(oid);
+#else
     oc_id = ((oid.hi & OID_FMT_CLASS_MASK) >> OID_FMT_CLASS_SHIFT) & 0xffff;
+#endif
 
     /* Get object class string */
     if(daos_oclass_id2name(oc_id, oclass_str) < 0)
@@ -1363,7 +1415,7 @@ H5_daos_pool_connect(H5_daos_acc_params_t *pool_acc_params, unsigned int flags,
     herr_t ret_value = SUCCEED;
 
     assert(pool_acc_params);
-    assert(!uuid_is_null(pool_acc_params->pool_uuid));
+    assert(pool_acc_params->pool);
     assert(poh_out);
     assert(req);
     assert(first_task);
@@ -1372,14 +1424,11 @@ H5_daos_pool_connect(H5_daos_acc_params_t *pool_acc_params, unsigned int flags,
     if(NULL == (connect_udata = (H5_daos_pool_connect_ud_t *)DV_malloc(sizeof(H5_daos_pool_connect_ud_t))))
         D_GOTO_ERROR(H5E_RESOURCE, H5E_CANTALLOC, FAIL, "can't allocate user data struct for pool connect task");
     connect_udata->req = req;
-    connect_udata->puuid = &pool_acc_params->pool_uuid;
+    connect_udata->pool = pool_acc_params->pool;
     connect_udata->poh = poh_out;
-    connect_udata->grp = pool_acc_params->pool_group;
+    connect_udata->sys = pool_acc_params->sys;
     connect_udata->flags = flags;
     connect_udata->info = pool_info_out;
-#if !defined(DAOS_API_VERSION_MAJOR) || DAOS_API_VERSION_MAJOR < 1
-    connect_udata->svc = NULL;
-#endif
 
     /* Create task for pool connect */
     if(H5_daos_create_daos_task(DAOS_OPC_POOL_CONNECT, *dep_task ? 1 : 0, *dep_task ? dep_task : NULL,
@@ -1438,42 +1487,24 @@ H5_daos_pool_connect_prep_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
         D_GOTO_ERROR(H5E_VOL, H5E_CANTINIT, -H5_DAOS_DAOS_GET_ERROR, "can't get private data for pool connect task");
 
     assert(udata->req);
-    assert(udata->puuid);
+    assert(udata->pool);
 
     /* Handle errors */
     H5_DAOS_PREP_REQ(udata->req, H5E_VOL);
 
-    if(uuid_is_null(*udata->puuid))
-        D_GOTO_ERROR(H5E_VOL, H5E_BADVALUE, -H5_DAOS_BAD_VALUE, "pool UUID is invalid");
-
     /* Set daos_pool_connect task args */
     if(NULL == (connect_args = daos_task_get_args(task)))
         D_GOTO_ERROR(H5E_IO, H5E_CANTINIT, -H5_DAOS_DAOS_GET_ERROR, "can't get arguments for pool connect task");
     memset(connect_args, 0, sizeof(*connect_args));
     connect_args->poh = udata->poh;
-    connect_args->grp = udata->grp;
+    connect_args->grp = udata->sys;
     connect_args->flags = udata->flags;
     connect_args->info = udata->info;
-    /* TODO that cast can be removed once DAOS task struct is fixed */
-    uuid_copy((unsigned char *)connect_args->uuid, *udata->puuid);
-
-#if !defined(DAOS_API_VERSION_MAJOR) || DAOS_API_VERSION_MAJOR < 1
-    {
-        char *pool_svcl_env = getenv("DAOS_SVCL");
-
-        if(!pool_svcl_env)
-            D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, -H5_DAOS_BAD_VALUE,
-                    "DAOS_SVCL environment variable must be set");
-
-        if(NULL == (udata->svc = daos_rank_list_parse(pool_svcl_env, ":")))
-            D_GOTO_ERROR(H5E_ARGS, H5E_CANTGET, -H5_DAOS_H5_GET_ERROR,
-                    "failed to parse service replica rank list from DAOS_SVCL environment variable");
-        if(udata->svc->rl_nr == 0 || udata->svc->rl_nr > H5_DAOS_MAX_SVC_REPLICAS)
-            D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, -H5_DAOS_BAD_VALUE,
-                    "not a valid service replica rank list");
-
-        connect_args->svc = udata->svc;
-    }
+#if CHECK_DAOS_API_VERSION(1, 4)
+    connect_args->pool = udata->pool;
+#else
+    if(uuid_parse(udata->pool, connect_args->uuid) < 0)
+        D_GOTO_ERROR(H5E_IO, H5E_CANTINIT, -H5_DAOS_DAOS_GET_ERROR, "invalid pool uuid");
 #endif
 
 done:
@@ -2611,16 +2642,23 @@ H5_daos_oid_encode(daos_obj_id_t *oid, uint64_t oidx, H5I_type_t obj_type,
     if(object_class == OC_UNKNOWN)
         object_class = file->fapl_cache.default_object_class;
 
-    /* Set the object class by default according to object type if not set from
-     * above */
-    if(object_class == OC_UNKNOWN)
-        object_class = (obj_type == H5I_DATASET) ? OC_SX : OC_S1;
-
     /* Generate oid */
 #if !defined(DAOS_API_VERSION_MAJOR) || DAOS_API_VERSION_MAJOR < 1
+    if(object_class == OC_UNKNOWN)
+        object_class = (obj_type == H5I_DATASET) ? OC_SX : OC_S1;
     daos_obj_generate_id(oid, object_feats, object_class, 0);
 #else
-    if (daos_obj_generate_oid(file->coh, oid, object_feats, object_class, 0, 0) != 0)
+    daos_oclass_hints_t hints = 0;
+
+    /** if user does not set default object class, use DAOS default, but set a large oclass for
+     * datasets, and small for other object types */
+    if(object_class == OC_UNKNOWN) {
+	    if (obj_type == H5I_DATASET)
+		    hints = DAOS_OCH_SHD_MAX;
+	    else
+		    hints = DAOS_OCH_SHD_DEF;
+    }
+    if (daos_obj_generate_oid(file->coh, oid, object_feats, object_class, hints, 0) != 0)
         D_GOTO_ERROR(H5E_VOL, H5E_CANTSET, FAIL, "Can't set object class");
 #endif
 
diff --git a/src/daos_vol.h b/src/daos_vol.h
index 68b543e..97286fe 100644
--- a/src/daos_vol.h
+++ b/src/daos_vol.h
@@ -209,7 +209,6 @@ do { \
 #ifndef DAOS_DEFAULT_GROUP_ID
 # define DAOS_DEFAULT_GROUP_ID "daos_server"
 #endif
-#define H5_DAOS_MAX_GRP_NAME     64
 #define H5_DAOS_MAX_SVC_REPLICAS 13
 
 /* Remove warnings when connector does not use callback arguments */
@@ -281,6 +280,9 @@ do { \
 #define H5_DAOS_SNAP_OPEN_ID "daos_snap_open"
 #endif
 
+/* Property to specify DAOS property */
+#define H5_DAOS_FILE_PROP_NAME "daos_prop_name"
+
 /* Property to specify DAOS object class */
 #define H5_DAOS_OBJ_CLASS_NAME "daos_object_class"
 
@@ -456,6 +458,13 @@ do { \
     assert((req)->in_progress); \
 } while(0)
 
+#if defined(DAOS_API_VERSION_MAJOR) && defined(DAOS_API_VERSION_MINOR)
+#define CHECK_DAOS_API_VERSION(major, minor)                                            \
+        ((DAOS_API_VERSION_MAJOR > (major))                                             \
+        || (DAOS_API_VERSION_MAJOR == (major) && DAOS_API_VERSION_MINOR >= (minor)))
+#else
+#define CHECK_DAOS_API_VERSION(major, minor) 0
+#endif
 
 /********************/
 /* Private Typedefs */
@@ -463,8 +472,8 @@ do { \
 
 /* DAOS-specific file/pool access parameters */
 typedef struct H5_daos_acc_params_t {
-    uuid_t pool_uuid;
-    char   pool_group[H5_DAOS_MAX_GRP_NAME + 1];
+    char   pool[DAOS_PROP_LABEL_MAX_LEN +1];
+    char   sys[DAOS_SYS_NAME_MAX + 1];
 } H5_daos_acc_params_t;
 
 /* Forward declaration of operation pool struct */
@@ -562,15 +571,17 @@ typedef struct H5_daos_file_t {
     H5_daos_item_t item; /* Must be first */
     daos_handle_t coh;
     daos_handle_t container_poh;
+    daos_prop_t *create_prop;
     daos_prop_t *cont_prop;
     char *file_name;
-    uuid_t uuid;
+    char cont[DAOS_PROP_LABEL_MAX_LEN + 1];
     H5_daos_acc_params_t facc_params;
     unsigned flags;
     daos_handle_t glob_md_oh;
     daos_obj_id_t glob_md_oid;
     struct H5_daos_group_t *root_grp;
     hid_t fapl_id;
+    hid_t fcpl_id;
     H5_daos_fapl_cache_t fapl_cache;
     H5_daos_enc_plist_cache_t def_plist_cache;
     MPI_Comm comm;
diff --git a/src/daos_vol_attr.c b/src/daos_vol_attr.c
index f18b175..3eda74b 100644
--- a/src/daos_vol_attr.c
+++ b/src/daos_vol_attr.c
@@ -6256,6 +6256,8 @@ H5_daos_attribute_iterate_by_name_comp_cb(tse_task_t *task, void H5VL_DAOS_UNUSE
                     tmp_char = p[udata->u.name_order_data.kds[i].kd_key_len];
                     p[udata->u.name_order_data.kds[i].kd_key_len] = '\0';
 
+		    H5_DAOS_WAIT_ON_ASYNC_CHAIN(udata->req, first_task, dep_task, H5E_ATTR, H5E_CANTINIT, FAIL);
+
                     /* Create task to call user-supplied operator callback function */
                     if(H5_daos_attribute_get_iter_op_task(udata, &p[2],
                             udata->req, &first_task, &dep_task) < 0)
diff --git a/src/daos_vol_file.c b/src/daos_vol_file.c
index 0ef5268..fb2b02f 100644
--- a/src/daos_vol_file.c
+++ b/src/daos_vol_file.c
@@ -45,19 +45,19 @@ typedef struct H5_daos_cont_op_info_t {
         struct {
             H5_daos_acc_params_t facc_params;
             daos_handle_t cont_poh;
-            uuid_t cont_uuid;
+            char cont[DAOS_PROP_LABEL_MAX_LEN +1];
             herr_t *delete_status;
         } cont_delete_info;
     } u;
 } H5_daos_cont_op_info_t;
 
 typedef struct get_obj_count_udata_t {
-    uuid_t file_id;
+    char file_id[DAOS_PROP_LABEL_MAX_LEN +1];
     ssize_t obj_count;
 } get_obj_count_udata_t;
 
 typedef struct get_obj_ids_udata_t {
-    uuid_t file_id;
+    char file_id[DAOS_PROP_LABEL_MAX_LEN +1];
     size_t max_objs;
     hid_t *oid_list;
     size_t obj_count;
@@ -67,6 +67,7 @@ typedef struct get_obj_ids_udata_t {
 /* Local Prototypes */
 /********************/
 
+static herr_t H5_daos_get_cont_props(hid_t fcpl_id, daos_prop_t **props);
 static herr_t H5_daos_get_file_access_info(hid_t fapl_id, H5_daos_acc_params_t *fa_out);
 #ifdef H5_DAOS_USE_TRANSACTIONS
 static int H5_daos_tx_open_prep_cb(tse_task_t *task, void *args);
@@ -102,7 +103,7 @@ static int H5_daos_cont_open_prep_cb(tse_task_t *task, void *args);
 static int H5_daos_cont_open_comp_cb(tse_task_t *task, void *args);
 static int H5_daos_cont_query_prep_cb(tse_task_t *task, void *args);
 static int H5_daos_cont_query_comp_cb(tse_task_t *task, void *args);
-static herr_t H5_daos_file_get_pool_uuid(H5_daos_file_t *file, const char *filepath);
+static herr_t H5_daos_file_get_pool(H5_daos_file_t *file, const char *filepath);
 static int H5_daos_handles_bcast_comp_cb(tse_task_t *task, void *args);
 static herr_t H5_daos_file_handles_bcast(H5_daos_file_t *file,
     H5_daos_req_t *req, tse_task_t **first_task, tse_task_t **dep_task);
@@ -127,6 +128,39 @@ static herr_t H5_daos_fill_enc_plist_cache(H5_daos_file_t *file, hid_t fapl_id);
 static herr_t H5_daos_get_obj_count_callback(hid_t id, void *udata);
 static herr_t H5_daos_get_obj_ids_callback(hid_t id, void *udata);
 
+static herr_t
+H5_daos_get_cont_props(hid_t fcpl_id, daos_prop_t **prop)
+{
+    char *prop_str = NULL;
+    htri_t prop_exists;
+    herr_t ret_value = SUCCEED;
+
+    assert(prop);
+
+    /* Make sure H5_DAOS_g is set. */
+    H5_DAOS_G_INIT(FAIL);
+
+    if((prop_exists = H5Pexist(fcpl_id, H5_DAOS_FILE_PROP_NAME)) < 0)
+        D_GOTO_ERROR(H5E_VOL, H5E_CANTGET, FAIL, "can't check for daos container property");
+    if(prop_exists) {
+        if(H5Pget(fcpl_id, H5_DAOS_FILE_PROP_NAME, &prop_str) < 0)
+            D_GOTO_ERROR(H5E_VOL, H5E_CANTGET, FAIL, "can't get container property");
+    } else {
+	prop_str = getenv("HDF5_DAOS_FILE_PROP");
+        if(prop_str == NULL)
+            D_GOTO_DONE(0);
+    }
+
+#if CHECK_DAOS_API_VERSION(1, 4)
+    if(prop_str) {
+        if(daos_prop_from_str(prop_str, strlen(prop_str), prop) != 0)
+            D_GOTO_ERROR(H5E_VOL, H5E_CANTGET, FAIL, "can't serialize container property");
+    }
+#endif
+done:
+    D_FUNC_LEAVE;
+}
+
 
 /*-------------------------------------------------------------------------
  * Function:    H5_daos_get_file_access_info
@@ -137,7 +171,7 @@ static herr_t H5_daos_get_obj_ids_callback(hid_t id, void *udata);
  *              this info may also be parsed from the following environment
  *              variables:
  *
- *              DAOS_POOL       - DAOS pool UUID to use
+ *              DAOS_POOL       - DAOS pool to use
  *              DAOS_POOL_GROUP - Process set name of the servers managing
  *                                the DAOS pool
  *
@@ -149,8 +183,8 @@ static herr_t
 H5_daos_get_file_access_info(hid_t fapl_id, H5_daos_acc_params_t *fa_out)
 {
     H5_daos_acc_params_t *local_fapl_info = NULL;
-    char *pool_uuid_env = getenv("DAOS_POOL");
-    char *pool_grp_env = getenv("DAOS_POOL_GROUP");
+    char *pool_env = getenv("DAOS_POOL");
+    char *sys_env = getenv("DAOS_SYS");
     herr_t ret_value = SUCCEED;
 
     assert(fa_out);
@@ -159,7 +193,6 @@ H5_daos_get_file_access_info(hid_t fapl_id, H5_daos_acc_params_t *fa_out)
     H5_DAOS_G_INIT(FAIL);
 
     memset(fa_out, 0, sizeof(*fa_out));
-    uuid_clear(fa_out->pool_uuid);
 
     /*
      * First, check to see if any info was set through the use of
@@ -168,13 +201,12 @@ H5_daos_get_file_access_info(hid_t fapl_id, H5_daos_acc_params_t *fa_out)
     if(H5Pget_vol_info(fapl_id, (void **) &local_fapl_info) < 0)
         D_GOTO_ERROR(H5E_PLIST, H5E_CANTGET, FAIL, "can't get VOL info struct");
     if(local_fapl_info) {
-        if(!pool_uuid_env && !uuid_is_null(local_fapl_info->pool_uuid)) {
-            uuid_copy(fa_out->pool_uuid, local_fapl_info->pool_uuid);
+        if(!pool_env) {
+            strcpy(fa_out->pool, local_fapl_info->pool);
         }
 
-        if(!pool_grp_env && (strlen(local_fapl_info->pool_group) > 0)) {
-            strncpy(fa_out->pool_group, local_fapl_info->pool_group, H5_DAOS_MAX_GRP_NAME - 1);
-            fa_out->pool_group[H5_DAOS_MAX_GRP_NAME] = '\0';
+        if(!sys_env && (strlen(local_fapl_info->sys) > 0)) {
+            strcpy(fa_out->pool, local_fapl_info->sys);
         }
     }
 
@@ -182,21 +214,15 @@ H5_daos_get_file_access_info(hid_t fapl_id, H5_daos_acc_params_t *fa_out)
      * Check for any information set via environment variables
      */
 
-    if(pool_uuid_env) {
-        /* Parse pool UUID from env. variable */
-        if(uuid_parse(pool_uuid_env, fa_out->pool_uuid) < 0)
-            D_GOTO_ERROR(H5E_VOL, H5E_CANTINIT, FAIL, "can't parse UUID from DAOS_POOL environment variable");
+    if(pool_env) {
+        /* Parse pool UUID/Label from env. variable */
+        strncpy(fa_out->pool, pool_env, DAOS_PROP_LABEL_MAX_LEN);
+	fa_out->pool[DAOS_PROP_LABEL_MAX_LEN] = 0;
     }
 
-    if(pool_grp_env) {
-        size_t pool_grp_name_len = strlen(pool_grp_env);
-
-        if(pool_grp_name_len > H5_DAOS_MAX_GRP_NAME)
-            D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "service group name is too long");
-        else if(pool_grp_name_len > 0) {
-            strncpy(fa_out->pool_group, pool_grp_env, H5_DAOS_MAX_GRP_NAME - 1);
-            fa_out->pool_group[H5_DAOS_MAX_GRP_NAME] = '\0';
-        }
+    if(sys_env) {
+	strncpy(fa_out->sys, sys_env, DAOS_SYS_NAME_MAX);
+	fa_out->sys[DAOS_SYS_NAME_MAX] = 0;
     }
 
     /*
@@ -209,12 +235,12 @@ H5_daos_get_file_access_info(hid_t fapl_id, H5_daos_acc_params_t *fa_out)
      * A default will be provided for the pool group field if unset.
      */
 
-    if(H5_daos_bypass_duns_g && uuid_is_null(fa_out->pool_uuid))
-        D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "DAOS pool UUID is not set");
+    if(H5_daos_bypass_duns_g && fa_out->pool == NULL)
+        D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "DAOS pool is not set");
 
-    if((!local_fapl_info && !pool_grp_env) || (0 == strlen(fa_out->pool_group))) {
-        strncpy(fa_out->pool_group, DAOS_DEFAULT_GROUP_ID, H5_DAOS_MAX_GRP_NAME - 1);
-        fa_out->pool_group[H5_DAOS_MAX_GRP_NAME] = '\0';
+    if((!local_fapl_info && !sys_env) || (0 == strlen(fa_out->sys))) {
+        strncpy(fa_out->sys, DAOS_DEFAULT_GROUP_ID, DAOS_SYS_NAME_MAX);
+        fa_out->sys[DAOS_SYS_NAME_MAX] = '\0';
     }
 
 done:
@@ -329,9 +355,9 @@ H5_daos_tx_open_comp_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
 
 
 /*-------------------------------------------------------------------------
- * Function:    H5_daos_file_get_pool_uuid
+ * Function:    H5_daos_file_get_pool
  *
- * Purpose:     Attempts to retrieve the DAOS pool UUID for a file by
+ * Purpose:     Attempts to retrieve the DAOS pool UUID/label for a file by
  *              calling duns_resolve_path on the parent directory.
  *
  * Return:      Non-negative on success/Negative on failure
@@ -339,7 +365,7 @@ H5_daos_tx_open_comp_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5_daos_file_get_pool_uuid(H5_daos_file_t *file, const char *filepath)
+H5_daos_file_get_pool(H5_daos_file_t *file, const char *filepath)
 {
     struct duns_attr_t duns_attr;
     char *fpath_copy = NULL;
@@ -370,7 +396,11 @@ H5_daos_file_get_pool_uuid(H5_daos_file_t *file, const char *filepath)
      * we will try other methods for retrieving the file's pool UUID.
      */
     if(0 == (ret = duns_resolve_path(dir_name, &duns_attr)))
-        uuid_copy(file->facc_params.pool_uuid, duns_attr.da_puuid);
+#if CHECK_DAOS_API_VERSION(1, 4)
+        strcpy(file->facc_params.pool, duns_attr.da_pool);
+#else
+        uuid_unparse(duns_attr.da_puuid, file->facc_params.pool);
+#endif
     else if(ENODATA != ret) {
         if(EOPNOTSUPP == ret)
             D_GOTO_ERROR(H5E_FILE, H5E_PATH, FAIL, "duns_resolve_path failed - DUNS not supported on file system");
@@ -383,7 +413,7 @@ H5_daos_file_get_pool_uuid(H5_daos_file_t *file, const char *filepath)
         free(fpath_copy);
 
     D_FUNC_LEAVE;
-} /* end H5_daos_file_get_pool_uuid() */
+} /* end H5_daos_file_get_pool() */
 
 
 /*-------------------------------------------------------------------------
@@ -795,6 +825,8 @@ H5_daos_file_create(const char *name, unsigned flags, hid_t fcpl_id,
     file->container_poh = DAOS_HDL_INVAL;
     file->glob_md_oh = DAOS_HDL_INVAL;
     file->root_grp = NULL;
+    file->create_prop = NULL;
+    file->fcpl_id = H5P_FILE_CREATE_DEFAULT;
     file->fapl_id = H5P_FILE_ACCESS_DEFAULT;
     file->item.rc = 1;
     file->comm = MPI_COMM_NULL;
@@ -810,26 +842,26 @@ H5_daos_file_create(const char *name, unsigned flags, hid_t fcpl_id,
     if((fapl_id != H5P_FILE_ACCESS_DEFAULT) && (file->fapl_id = H5Pcopy(fapl_id)) < 0)
         D_GOTO_ERROR(H5E_FILE, H5E_CANTCOPY, NULL, "failed to copy fapl");
 
+    /* Get needed cont create properties */
+    if(H5_daos_get_cont_props(fcpl_id, &file->create_prop) < 0)
+        D_GOTO_ERROR(H5E_FILE, H5E_CANTGET, NULL, "can't get DAOS properties");
     /* Get needed file/pool access information */
     if(H5_daos_get_file_access_info(fapl_id, &file->facc_params) < 0)
         D_GOTO_ERROR(H5E_FILE, H5E_CANTGET, NULL, "can't get DAOS info struct");
 
     /* Try to retrieve file's pool UUID using DUNS */
-    if(!H5_daos_bypass_duns_g &&
-            H5_daos_file_get_pool_uuid(file, file->file_name) < 0)
+    if(!H5_daos_bypass_duns_g && H5_daos_file_get_pool(file, file->file_name) < 0)
         D_GOTO_ERROR(H5E_FILE, H5E_CANTINIT, NULL, "can't retrieve file's DAOS pool UUID");
 
-    /* It is an error if the file's pool UUID is still unset at this point */
-    if(uuid_is_null(file->facc_params.pool_uuid))
-        D_GOTO_ERROR(H5E_VOL, H5E_CANTINIT, NULL, "file's pool UUID is not set - try setting DAOS_POOL environment variable");
-
     /* Set MPI info on file object */
     if(H5_daos_get_mpi_info(fapl_id, &file->comm, &file->info,
             &file->my_rank, &file->num_procs) < 0)
         D_GOTO_ERROR(H5E_FILE, H5E_CANTSET, NULL, "can't set MPI container info");
 
     /* Hash file name to create uuid */
-    H5_daos_hash128(name, &file->uuid);
+    uuid_t uuid;
+    H5_daos_hash128(name, &uuid);
+    uuid_unparse(uuid, file->cont);
 
     /* Fill FAPL cache */
     if(H5_daos_fill_fapl_cache(file, fapl_id) < 0)
@@ -1007,7 +1039,13 @@ H5_daos_cont_create(H5_daos_file_t *file, unsigned flags, H5_daos_req_t *req,
     memset(&create_udata->duns_attr, 0, sizeof(struct duns_attr_t));
     create_udata->duns_attr.da_type = DAOS_PROP_CO_LAYOUT_HDF5;
     create_udata->duns_attr.da_oclass_id = file->fapl_cache.default_object_class;
-    uuid_copy(create_udata->duns_attr.da_cuuid, file->uuid);
+    if(file->create_prop)
+        create_udata->duns_attr.da_props = file->create_prop;
+#if CHECK_DAOS_API_VERSION(1, 4)
+    strcpy(create_udata->duns_attr.da_cont, file->cont);
+#else
+    uuid_parse(file->cont, create_udata->duns_attr.da_cuuid);
+#endif
 
     if(!H5_daos_bypass_duns_g) {
         /* Create task to attempt to resolve DUNS path. This task will handle
@@ -1210,7 +1248,7 @@ H5_daos_duns_create_path_task(tse_task_t *task)
  *
  * Purpose:     Prepare callback for asynchronous duns_create_path.
  *              Currently checks for errors from previous tasks then copies
- *              the DAOS pool UUID from the daos_pool_info_t struct into
+ *              the DAOS pool from the daos_pool_info_t struct into
  *              the duns_attr_t struct for duns_create_path.
  *
  * Return:      Success:        0
@@ -1234,7 +1272,11 @@ H5_daos_duns_create_path_prep_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
     H5_DAOS_PREP_REQ(udata->req, H5E_FILE);
 
     /* Set the pool UUID for duns_create_path */
-    uuid_copy(udata->duns_attr.da_puuid, udata->req->file->facc_params.pool_uuid);
+#if CHECK_DAOS_API_VERSION(1, 4)
+    strcpy(udata->duns_attr.da_pool, udata->req->file->facc_params.pool);
+#else
+    uuid_parse(udata->req->file->facc_params.pool, udata->duns_attr.da_puuid);
+#endif
 
 done:
     if(ret_value < 0)
@@ -1276,8 +1318,14 @@ H5_daos_duns_create_path_comp_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
         udata->req->failed_task = "DUNS path creation";
     } /* end if */
 
-    uuid_copy(udata->req->file->uuid, udata->duns_attr.da_cuuid);
+#if CHECK_DAOS_API_VERSION(1, 4)
+    strcpy(udata->req->file->cont, udata->duns_attr.da_cont);
+#else
+    uuid_unparse(udata->duns_attr.da_cuuid, udata->req->file->cont);
+#endif
 
+    if (udata->req->file->create_prop)
+        daos_prop_free(udata->req->file->create_prop);
 done:
     /* Free private data if we haven't released ownership */
     if(udata) {
@@ -1341,9 +1389,9 @@ H5_daos_cont_create_prep_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
     if(NULL == (create_args = daos_task_get_args(task)))
         D_GOTO_ERROR(H5E_IO, H5E_CANTINIT, -H5_DAOS_DAOS_GET_ERROR, "can't get arguments for container create task");
     memset(create_args, 0, sizeof(*create_args));
+    create_args->prop = udata->duns_attr.da_props;
     create_args->poh = *udata->poh;
-    /* TODO that cast can be removed once DAOS task struct is fixed */
-    uuid_copy((unsigned char *)create_args->uuid, udata->req->file->uuid);
+    uuid_parse(udata->req->file->cont, create_args->uuid);
 
 done:
     if(ret_value < 0)
@@ -1385,6 +1433,9 @@ H5_daos_cont_create_comp_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
         udata->req->failed_task = "DAOS container create";
     } /* end if */
 
+    if (udata->req->file->create_prop)
+        daos_prop_free(udata->req->file->create_prop);
+
 done:
     /* Free private data if we haven't released ownership */
     if(udata) {
@@ -1530,12 +1581,8 @@ H5_daos_file_open(const char *name, unsigned flags, hid_t fapl_id,
 
     /* Try to retrieve file's pool UUID using DUNS */
     if(!H5_daos_bypass_duns_g &&
-            H5_daos_file_get_pool_uuid(file, file->file_name) < 0)
-        D_GOTO_ERROR(H5E_FILE, H5E_CANTINIT, NULL, "can't retrieve file's DAOS pool UUID");
-
-    /* It is an error if the file's pool UUID is still unset at this point */
-    if(uuid_is_null(file->facc_params.pool_uuid))
-        D_GOTO_ERROR(H5E_VOL, H5E_CANTINIT, NULL, "file's pool UUID is not set - try setting DAOS_POOL environment variable");
+            H5_daos_file_get_pool(file, file->file_name) < 0)
+        D_GOTO_ERROR(H5E_FILE, H5E_CANTINIT, NULL, "can't retrieve file's DAOS pool");
 
     /* Set MPI info on file object */
     if(H5_daos_get_mpi_info(fapl_id, &file->comm, &file->info,
@@ -1543,8 +1590,12 @@ H5_daos_file_open(const char *name, unsigned flags, hid_t fapl_id,
         D_GOTO_ERROR(H5E_FILE, H5E_CANTSET, NULL, "can't set MPI container info");
 
     /* Hash file name to create uuid if bypassing DUNS */
-    if(H5_daos_bypass_duns_g)
-        H5_daos_hash128(name, &file->uuid);
+    if(H5_daos_bypass_duns_g) {
+        uuid_t uuid;
+
+        H5_daos_hash128(name, &uuid);
+	uuid_unparse(uuid, file->cont);
+    }
 
 #ifdef DV_HAVE_SNAP_OPEN_ID
     if(H5Pget(fapl_id, H5_DAOS_SNAP_OPEN_ID, &snap_id) < 0)
@@ -2167,10 +2218,12 @@ H5_daos_duns_resolve_path_comp_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
             assert(udata->req->file);
 
             /* Set parameters for file delete operation */
-            uuid_copy(udata->u.cont_delete_info.facc_params.pool_uuid, udata->duns_attr.da_puuid);
-            strncpy(udata->u.cont_delete_info.facc_params.pool_group,
-                    udata->req->file->facc_params.pool_group, H5_DAOS_MAX_GRP_NAME - 1);
-            udata->u.cont_delete_info.facc_params.pool_group[H5_DAOS_MAX_GRP_NAME] = '\0';
+#if CHECK_DAOS_API_VERSION(1, 4)
+	    strcpy(udata->u.cont_delete_info.facc_params.pool, udata->duns_attr.da_pool);
+#else
+	    uuid_unparse(udata->duns_attr.da_puuid, udata->u.cont_delete_info.facc_params.pool);
+#endif
+            strcpy(udata->u.cont_delete_info.facc_params.sys, udata->req->file->facc_params.sys);
 
             if(H5_daos_file_delete(udata->path, &udata->u.cont_delete_info.facc_params,
                     TRUE, NULL, udata->req, &first_task, &dep_task) < 0)
@@ -2185,10 +2238,18 @@ H5_daos_duns_resolve_path_comp_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
          * copy the resolved pool UUID into the file object.
          */
         if(udata->op_type == H5_DAOS_CONT_OPEN)
-            uuid_copy(udata->req->file->facc_params.pool_uuid, udata->duns_attr.da_puuid);
+#if CHECK_DAOS_API_VERSION(1, 4)
+            strcpy(udata->req->file->facc_params.pool, udata->duns_attr.da_pool);
+#else
+	    uuid_unparse(udata->duns_attr.da_puuid, udata->req->file->facc_params.pool);
+#endif
         /* If deleting a DUNS path/DAOS container, copy the resolved pool UUID for the delete operation */
         else if(udata->op_type == H5_DAOS_CONT_DESTROY)
-            uuid_copy(udata->u.cont_delete_info.facc_params.pool_uuid, udata->duns_attr.da_puuid);
+#if CHECK_DAOS_API_VERSION(1, 4)
+            strcpy(udata->u.cont_delete_info.facc_params.pool, udata->duns_attr.da_pool);
+#else
+            uuid_unparse(udata->duns_attr.da_puuid, udata->u.cont_delete_info.facc_params.pool);
+#endif
     } /* end else */
 
 done:
@@ -2252,15 +2313,22 @@ H5_daos_cont_open_prep_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
 
     /* Set file's UUID if necessary */
     if(!H5_daos_bypass_duns_g && 0 == (udata->flags & H5F_ACC_CREAT))
-        uuid_copy(udata->req->file->uuid, udata->duns_attr.da_cuuid);
+#if CHECK_DAOS_API_VERSION(1, 4)
+        strcpy(udata->req->file->cont, udata->duns_attr.da_cont);
+#else
+	uuid_unparse(udata->duns_attr.da_cuuid, udata->req->file->cont);
+#endif
 
     /* Set daos_cont_open task args */
     if(NULL == (open_args = daos_task_get_args(task)))
         D_GOTO_ERROR(H5E_IO, H5E_CANTINIT, -H5_DAOS_DAOS_GET_ERROR, "can't get arguments for container open task");
     memset(open_args, 0, sizeof(*open_args));
     open_args->poh = *udata->poh;
-    /* TODO that cast can be removed once DAOS task struct is fixed */
-    uuid_copy((unsigned char *)open_args->uuid, udata->req->file->uuid);
+#if CHECK_DAOS_API_VERSION(1, 4)
+    open_args->cont = udata->req->file->cont;
+#else
+    uuid_unparse(udata->req->file->cont, open_args->uuid);
+#endif
     open_args->flags = udata->flags & H5F_ACC_RDWR ? DAOS_COO_RW : DAOS_COO_RO;
     open_args->coh = &udata->req->file->coh;
 
@@ -2467,7 +2535,7 @@ H5_daos_file_get(void *_item, H5VL_file_get_t get_type, hid_t H5VL_DAOS_UNUSED d
 
             udata.obj_count = 0;
 
-            uuid_copy(udata.file_id, file->uuid);
+            strcpy(udata.file_id, file->cont);
 
             if(obj_types & H5F_OBJ_FILE)
                 if(H5Iiterate(H5I_FILE, H5_daos_get_obj_count_callback, &udata) < 0)
@@ -2504,7 +2572,7 @@ H5_daos_file_get(void *_item, H5VL_file_get_t get_type, hid_t H5VL_DAOS_UNUSED d
             udata.oid_list = oid_list;
 
             if(max_ids > 0) {
-                uuid_copy(udata.file_id, file->uuid);
+                strcpy(udata.file_id, file->cont);
 
                 if(obj_types & H5F_OBJ_FILE)
                     if(H5Iiterate(H5I_FILE, H5_daos_get_obj_ids_callback, &udata) < 0)
@@ -2555,7 +2623,7 @@ H5_daos_file_specific(void *item, H5VL_file_specific_t specific_type,
     hid_t dxpl_id, void **req, va_list arguments)
 {
     H5_daos_file_t *file = NULL;
-    H5_daos_acc_params_t faccess_info = {0};
+    H5_daos_acc_params_t faccess_info = {{0}, {0}};
     H5_daos_mpi_ibcast_ud_t *bcast_info = NULL;
     H5_daos_req_t *int_req = NULL;
     tse_task_t *first_task = NULL;
@@ -2724,7 +2792,7 @@ H5_daos_file_specific(void *item, H5VL_file_specific_t specific_type,
             if(!file || !file2)
                 *is_equal = FALSE;
             else
-                *is_equal = (memcmp(&file->uuid, &file2->uuid, sizeof(file->uuid)) == 0);
+                *is_equal = (strcmp(file->cont, file2->cont) == 0);
             break;
         } /* H5VL_FILE_IS_EQUAL */
 
@@ -2840,7 +2908,7 @@ H5_daos_file_delete(const char *file_path, H5_daos_acc_params_t *file_acc_params
     destroy_udata->u.cont_delete_info.delete_status = delete_status;
     destroy_udata->u.cont_delete_info.facc_params = *file_acc_params;
 
-    if(uuid_is_null(file_acc_params->pool_uuid)) {
+    if(strlen(file_acc_params->pool) == 0) {
         if(!H5_daos_bypass_duns_g) {
             /* Create task to resolve given pathname */
             if(H5_daos_duns_resolve_path(destroy_udata, NULL,
@@ -2848,12 +2916,16 @@ H5_daos_file_delete(const char *file_path, H5_daos_acc_params_t *file_acc_params
                 D_GOTO_ERROR(H5E_FILE, H5E_CANTINIT, FAIL, "can't resolve DUNS path");
         }
         else
-            D_GOTO_ERROR(H5E_FILE, H5E_BADVALUE, FAIL, "pool UUID is NULL");
+            D_GOTO_ERROR(H5E_FILE, H5E_BADVALUE, FAIL, "pool is NULL");
     }
 
     /* Hash file name to create container uuid if bypassing DUNS */
-    if(H5_daos_bypass_duns_g)
-        H5_daos_hash128(file_path, &destroy_udata->u.cont_delete_info.cont_uuid);
+    if(H5_daos_bypass_duns_g) {
+        uuid_t uuid;
+
+	H5_daos_hash128(file_path, &uuid);
+	uuid_unparse(uuid, destroy_udata->u.cont_delete_info.cont);
+    }
 
     /* Create tasks to connect to container's pool and destroy the DUNS path/DAOS container. */
     if(H5_daos_pool_connect(&destroy_udata->u.cont_delete_info.facc_params, DAOS_PC_RW,
@@ -3196,9 +3268,17 @@ H5_daos_cont_destroy_prep_cb(tse_task_t *task, void H5VL_DAOS_UNUSED *args)
     destroy_args->poh = *udata->poh;
     destroy_args->force = 1;
     if(udata->op_type == H5_DAOS_CONT_DESTROY)
-        uuid_copy(destroy_args->uuid, udata->u.cont_delete_info.cont_uuid);
-    else
-        uuid_copy(destroy_args->uuid, udata->req->file->uuid);
+#if CHECK_DAOS_API_VERSION(1, 4)
+        destroy_args->cont = udata->u.cont_delete_info.cont;
+#else
+        uuid_unparse(udata->u.cont_delete_info.cont, destroy_args->uuid);
+#endif
+	else
+#if CHECK_DAOS_API_VERSION(1, 4)
+        destroy_args->cont = udata->req->file->cont;
+#else
+        uuid_unparse(udata->req->file->cont, destroy_args->uuid);
+#endif
 
 done:
     if(ret_value < 0)
@@ -3777,7 +3857,7 @@ H5_daos_get_obj_count_callback(hid_t id, void *udata)
         if(NULL == (cur_obj = (H5_daos_obj_t *) H5VLobject(id)))
             D_GOTO_ERROR(H5E_VOL, H5E_CANTGET, H5_ITER_ERROR, "can't retrieve VOL object for ID");
 
-        if(!uuid_compare(cur_obj->item.file->uuid, count_udata->file_id))
+        if(!strcmp(cur_obj->item.file->cont, count_udata->file_id))
             count_udata->obj_count++;
     } /* end if */
 
@@ -3823,7 +3903,7 @@ H5_daos_get_obj_ids_callback(hid_t id, void *udata)
             D_GOTO_ERROR(H5E_VOL, H5E_CANTGET, H5_ITER_ERROR, "can't retrieve VOL object for ID");
 
         if(id_udata->obj_count < id_udata->max_objs) {
-            if(!uuid_compare(cur_obj->item.file->uuid, id_udata->file_id))
+            if(!strcmp(cur_obj->item.file->cont, id_udata->file_id))
                 id_udata->oid_list[id_udata->obj_count++] = id;
         }
         else
diff --git a/src/daos_vol_link.c b/src/daos_vol_link.c
index d7f14bc..15d8eb0 100644
--- a/src/daos_vol_link.c
+++ b/src/daos_vol_link.c
@@ -118,6 +118,7 @@ typedef struct H5_daos_link_write_ud_t {
     uint64_t max_corder;
     tse_task_t *link_write_task;
     tse_task_t *update_task;
+    tse_task_t *metatask;
 } H5_daos_link_write_ud_t;
 
 /* Task user data for writing link creation order info to a group */
@@ -996,7 +997,6 @@ H5_daos_link_write_task(tse_task_t *task)
          * ownership of udata */
         assert(!first_task);
         first_task = udata->update_task;
-        dep_task = udata->update_task;
         udata = NULL;
     } /* end else */
 
@@ -1911,6 +1911,7 @@ H5_daos_link_create_task(tse_task_t *task)
 	    if(H5_daos_create_task(H5_daos_metatask_autocomplete, 1, &dep_task,  NULL, NULL, NULL, &metatask) < 0)
 		D_DONE_ERROR(H5E_LINK, H5E_CANTINIT, FAIL, "can't create metatask for link create");
 
+	    tse_task_register_deps(task, 1, &metatask);
             /* Schedule metatask */
             if(0 != (ret = tse_task_schedule(metatask, false)))
     	        D_DONE_ERROR(H5E_LINK, H5E_CANTINIT, FAIL, "can't schedule metatask for link create: %s", H5_daos_err_to_string(ret));
@@ -1936,13 +1937,6 @@ H5_daos_link_create_task(tse_task_t *task)
         assert(!first_task);
     } /* end else */
 
-    /* Return task to task list */
-    if(H5_daos_task_list_put(H5_daos_task_list_g, task) < 0)
-        D_DONE_ERROR(H5E_LINK, H5E_CLOSEERROR, -H5_DAOS_TASK_LIST_ERROR, "can't return task to task list");
-
-    /* Complete this task */
-    tse_task_complete(task, ret_value);
-
     D_FUNC_LEAVE;
 } /* end H5_daos_link_create_task() */
 
diff --git a/src/daos_vol_obj.c b/src/daos_vol_obj.c
index 4166935..71398e4 100644
--- a/src/daos_vol_obj.c
+++ b/src/daos_vol_obj.c
@@ -4631,7 +4631,11 @@ H5_daos_object_get_info_task(tse_task_t *task)
     /* Basic fields */
     if(udata->fields & H5O_INFO_BASIC) {
         uint64_t fileno64;
-        uint8_t *uuid_p = (uint8_t *)&(*udata->target_obj_p)->item.file->uuid;
+        uuid_t cuuid;
+        uint8_t *uuid_p;
+
+	uuid_parse((*udata->target_obj_p)->item.file->cont, cuuid);
+	uuid_p = (uint8_t *)&cuuid;
 
         /* Use the lower <sizeof(unsigned long)> bytes of the file uuid
          * as the fileno.  Ideally we would write separate 32 and 64 bit
diff --git a/src/daos_vol_public.h b/src/daos_vol_public.h
index c05c0cd..e058c18 100644
--- a/src/daos_vol_public.h
+++ b/src/daos_vol_public.h
@@ -59,20 +59,33 @@ extern "C" {
 /**
  * Modify the file access property list to use the DAOS VOL connector.
  *
- * \pool_uuid identifies the UUID of the DAOS pool to connect to.
+ * \pool identifies the UUID or label of the DAOS pool to connect to.
  *
- * \pool_grp identifies the server group name to use when connecting to
- * the DAOS pool. This may be NULL, in which case a default group name
+ * \sys_name identifies the DAOS system name to use when connecting to
+ * the DAOS pool. This may be NULL, in which case a default system name
  * is used.
  *
  * \param fapl_id   [IN]    File access property list
- * \param pool_uuid [IN]    DAOS pool UUID
- * \param pool_grp  [IN]    Process set name of the DAOS servers managing the pool
+ * \param pool      [IN]    DAOS pool UUID
+ * \param sys_name  [IN]    Process set name of the DAOS servers managing the pool
  *
  * \return Non-negative on success/Negative on failure
  */
 H5VL_DAOS_PUBLIC herr_t
-H5Pset_fapl_daos(hid_t fapl_id, const uuid_t pool_uuid, const char *pool_grp);
+H5Pset_fapl_daos(hid_t fapl_id, const char *pool, const char *sys_name);
+
+/**
+ * Sets DAOS properties on the file creation property list when creating a container.  This allows
+ * users to set properties like the rf factor, ACLs, etc. \prop_str must be of the following format:
+ * prop_entry_name1:value1;prop_entry_name2:value2;prop_entry_name3:value3;
+ *
+ * \param fcpl_id   [IN]    File creation property list
+ * \param prop_str  [IN]    A serialized string of DAOS properties & values.
+ *
+ * \return Non-negative on success/Negative on failure
+ */
+H5VL_DAOS_PUBLIC herr_t
+H5daos_set_prop(hid_t fcpl_id, const char *prop_str);
 
 /**
  * Sets the provided DAOS object class on the given property list.
@@ -180,7 +193,7 @@ H5VL_DAOS_PUBLIC herr_t H5Pset_daos_snap_open(hid_t fapl_id,
  * API routines for external testing
  */
 H5VL_DAOS_PUBLIC herr_t H5daos_get_poh(hid_t file_id, daos_handle_t *poh);
-H5VL_DAOS_PUBLIC herr_t H5daos_get_pool_uuid(hid_t file_id, uuid_t *pool_uuid);
+H5VL_DAOS_PUBLIC herr_t H5daos_get_pool(hid_t file_id, char *pool);
 
 #ifdef __cplusplus
 }
diff --git a/src/daos_vol_testing.c b/src/daos_vol_testing.c
index 30a5423..05e1eb6 100644
--- a/src/daos_vol_testing.c
+++ b/src/daos_vol_testing.c
@@ -55,7 +55,7 @@ H5daos_get_poh(hid_t file_id, daos_handle_t *poh)
 
 
 /*-------------------------------------------------------------------------
- * Function:    H5daos_get_pool_uuid
+ * Function:    H5daos_get_pool
  *
  * Purpose:     Internal API function to return the pool UUID for a file.
  *
@@ -64,7 +64,7 @@ H5daos_get_poh(hid_t file_id, daos_handle_t *poh)
  *-------------------------------------------------------------------------
  */
 herr_t
-H5daos_get_pool_uuid(hid_t file_id, uuid_t *pool_uuid)
+H5daos_get_pool(hid_t file_id, char *pool)
 {
     H5_daos_file_t *file = NULL;
     herr_t ret_value = SUCCEED;
@@ -73,15 +73,15 @@ H5daos_get_pool_uuid(hid_t file_id, uuid_t *pool_uuid)
 
     if(file_id < 0)
         D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "file ID is invalid");
-    if(!pool_uuid)
-        D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "pool_uuid pointer is NULL");
+    if(!pool)
+        D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "pool pointer is NULL");
 
     if(NULL == (file = (H5_daos_file_t *)H5VLobject(file_id)))
         D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "VOL object is NULL");
     if(H5I_FILE != file->item.type)
         D_GOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "object is not a file");
 
-    uuid_copy(*pool_uuid, file->facc_params.pool_uuid);
+    strcpy(pool, file->facc_params.pool);
 
 done:
     D_FUNC_LEAVE_API;
diff --git a/test/daos_vol/h5daos_test_oclass.c b/test/daos_vol/h5daos_test_oclass.c
index 6f643b9..f3a587d 100644
--- a/test/daos_vol/h5daos_test_oclass.c
+++ b/test/daos_vol/h5daos_test_oclass.c
@@ -347,6 +347,12 @@ main( int argc, char** argv )
         goto error;
     }
 
+    /** set RF0 property on container */
+    if(H5daos_set_prop(fcpl_id, "rf:0") < 0) {
+        nerrors++;
+        goto error;
+    }
+
     /* First test: both default */
     TESTING("default FCPL and FAPL");
     nerrors += test_oclass(fcpl_id, fapl_id, "S1", "S1", "SX");
diff --git a/test/daos_vol/h5daos_test_recovery.c b/test/daos_vol/h5daos_test_recovery.c
index af115f6..c847c76 100644
--- a/test/daos_vol/h5daos_test_recovery.c
+++ b/test/daos_vol/h5daos_test_recovery.c
@@ -81,12 +81,9 @@ typedef struct {
 /*
  * Global variables
  */
-uuid_t pool_uuid;
+char   pool[DAOS_PROP_LABEL_MAX_LEN + 1];
 int    mpi_rank;
 static int    mpi_size;
-#if !defined(DAOS_API_VERSION_MAJOR) || DAOS_API_VERSION_MAJOR < 1
-static const d_rank_list_t *svcl;
-#endif
 static int    *wdata, *rdata;
 static int    *map_keys, *map_vals, *map_vals_out;
 static int    *attr_write, *attr_read;
@@ -113,7 +110,6 @@ static int figure_out_op(const char *);
 static void inject_fault(d_rank_t which_server)
 {
     char                     dmg_cmd[100];
-    char		     pool_string[256];
     int                      rc;
 
     if(MAINPROCESS) {
@@ -126,29 +122,13 @@ static void inject_fault(d_rank_t which_server)
         }
 
         /* Exclude the server from the pool */
-#if !defined(DAOS_API_VERSION_MAJOR) || DAOS_API_VERSION_MAJOR < 1
-        struct d_tgt_list targets;
-        int tgt = -1;
-
-        targets.tl_nr = 1;
-        targets.tl_ranks = &which_server;
-        tgt = -1;
-        targets.tl_tgts = &tgt;
-
-        if(daos_pool_tgt_exclude(pool_uuid, "daos_server", svcl, &targets, NULL) < 0) {
-            printf("daos_pool_tgt_exclude failed");
-            return;
-        }
-#else
-        uuid_unparse(pool_uuid, &pool_string[0]);
         snprintf(dmg_cmd, sizeof(dmg_cmd),
-                "dmg pool exclude -i --pool=%s --ranks=%d", pool_string, which_server);
+                "dmg pool exclude -i --pool=%s --ranks=%d", pool, which_server);
         rc = system(dmg_cmd);
         if (rc != 0) {
             printf(" %s failed with rc %#x\n", dmg_cmd, rc);
             return;
         }
-#endif
 
         fprintf(stdout, "\n\n\n\n        ========>>> Killed and excluded the server (rank %d)\n\n\n\n", which_server);
     }
@@ -1119,7 +1099,6 @@ static int figure_out_op(const char *str)
 int
 main( int argc, char** argv )
 {
-    char           file_pool_uuid[256];
     char           filename[NAME_LENGTH];
     hid_t          fapl_id = -1, file_id = -1;
     char          *pool_string = NULL;
@@ -1140,24 +1119,6 @@ main( int argc, char** argv )
         goto error;
     }
 
-#if !defined(DAOS_API_VERSION_MAJOR) || DAOS_API_VERSION_MAJOR < 1
-    /* Try to retrieve the SVCL from the DAOS_SVCL environment variable */
-    {
-        char *pool_svcl_env = getenv("DAOS_SVCL");
-
-        if(pool_svcl_env) {
-            if(NULL == (svcl = daos_rank_list_parse(pool_svcl_env, ":"))) {
-                printf("Can't retrieve SVCL from DAOS_SVCL environment variable\n\n");
-                goto error;
-            }
-        }
-        else {
-            printf("DAOS_SVCL environment variable must be set\n");
-            goto error;
-        }
-    }
-#endif
-
     snprintf(filename, NAME_LENGTH, "%s", FILENAME);
 
     if((fapl_id = H5Pcreate(H5P_FILE_ACCESS)) < 0) {
@@ -1191,28 +1152,19 @@ main( int argc, char** argv )
     }
 
     if (NULL != (pool_string = getenv("DAOS_POOL"))) {
-        if (0 != uuid_parse(pool_string, pool_uuid)) {
-            printf("Could not parse pool UUID\n\n");
-            goto error;
-        }
+        strcpy(pool, pool_string);
     }
     else {
         /* Try to retrieve pool UUID from the file */
-        if(H5daos_get_pool_uuid(file_id, &pool_uuid) < 0) {
+        if(H5daos_get_pool(file_id, pool) < 0) {
             printf("Can't retrieve file's pool UUID\n\n");
             goto error;
         }
-
-        uuid_unparse(pool_uuid, file_pool_uuid);
-        pool_string = file_pool_uuid;
     }
 
     if (MAINPROCESS) {
         fprintf(stdout, "Test parameters:\n\n");
-        fprintf(stdout, "  - Pool UUID: %s\n", pool_string);
-#if !defined(DAOS_API_VERSION_MAJOR) || DAOS_API_VERSION_MAJOR < 1
-        fprintf(stdout, "  - POOL SVCL: %s\n", getenv("DAOS_SVCL"));
-#endif
+        fprintf(stdout, "  - Pool: %s\n", pool);
         fprintf(stdout, "  - Test File name: %s\n", filename);
         fprintf(stdout, "\n\n");
     }
